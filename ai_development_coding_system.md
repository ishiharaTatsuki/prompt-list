まず最初に片付けておこう。vibe coding（バイブコーディング）が問題なんじゃない。問題はあなた自身だ。

AIコーディングエージェントに話しかければソフトウェアを出荷できる、と聞いた。で、あなたは自分が魔法使いになった気になった。だからAIを開いて、アプリのアイデアを一文で説明して、クソみたいな魔法が返ってくると期待した。

でも返ってきたのは、壊れたコード、ハルシネーションしたUIや色、ルーティングも接続もされていないページ、そして「なんとなく」動くけど結局ほとんど動かないアプリだった。

そしてあなたは、そのミスをAIのせいにした。バカみたいに。

真実はこうだ。AIがハルシネーションするのは壊れているからじゃない。あなたが掴ませるものを何も与えなかったからだ。

構造も、明瞭さも、土台もない。

vibe codingは機能する。だがそれは、あなたが何を作っているのか理解し、AIエージェントが働ける「本当に包括的なシステム」を与えた場合に限る。ここから先は、あなたが知るべきすべてだ。ビルディングブロック、語彙、本当のワークフロー――原始人でもできるくらい簡単に説明する。

これを読んでもまだ出荷できないなら、問題は情報ではなく努力だ。

これは流し読みして忘れるスレじゃない。vibe codingの「最初から最後までの完全なシステム」だ。今すぐブックマークしろ。Clawdbotのメモリに保存しろ。

新しいプロジェクトを始めるたびに戻ってこい。これをリファレンスマニュアルとして扱う人は、とんでもないものを作る。流し読みする人は、ずっと詰んだまま壊れ続ける。

さあ、あなたを直そう。

## 1: なぜ失敗しているのか

あなたが失敗している理由は、基礎をすっ飛ばしたからだ。

コンポーネント（component）が何か知らない。ステート（state）が何を意味するか知らない。ボタンをクリックしても何も起きない理由が分からない。ノートPCでは見た目が良いのに、スマホでは崩れる理由が分からない。

そして、これらを知らないから、AIに説明できない。

AIは翻訳者だ。あなたの意図をコードに変換する。でも意図がクソなら、コードもクソになる。欲しいものを言語化できないなら、AIは推測する。そして推測は積み重なって、完全で純粋なカオスになる。

修正は「より良いプロンプト」ではない。修正は「より良い理解」だ。

何を作っているか分かれば、プロンプトは自明になる。何を求めればいいかがようやく分かるから、言葉が自然に出てくる。

## 2: ドキュメント・ファーストのシステム

ここで全員が間違える。

Cursorを開き、チャットを開き、アプリの説明を始めて、AIに即コーディングを始めさせる。計画なし、参照なし、真実のソース（source of truth）なし。

これが、最初の数ファイルを書いたあたりでプロジェクトが崩壊する理由だ。

本物のシステムは「ドキュメントが先、コードが後」だ。必ずこうしろ。

コードを1行でも書く前に、プロジェクトのカノニカル（正典）なドキュメントMarkdownファイルを書け。あなたが何を作るのかを、明確に、具体的に、曖昧さゼロで説明する。

なぜか？ AIコーディングツールは「能力は高いが確信度は低い」状態で動く。構造的なガードレールなしにタスクを実行する。固定された制約と権威あるドキュメントがないと、AIは要件をハルシネーションし、勝手にアーキテクチャの意思決定をし、あなたが一度も言語化していない問題を解くコードを作り出す。

失敗モードはコーディング能力の不足ではない。失敗モードは規律とコンテキスト保存の不足だ。

コードに触る前に書くべきドキュメントスタックがある。プロジェクト全体を定義する6つのカノニカルなドキュメントに加えて、セッションを跨いでAIを整列させ、持続させるためのファイル群だ。

### カノニカルドキュメント（あなたのナレッジベース）

1. **PRD.md（Product Requirements Document）**  
   完全な仕様書。何を作るのか、誰のためか、どんな機能が存在するか、スコープ内は何か、そして明確にスコープ外は何か。ユーザーストーリー、成功基準、非目標（non-goals）。

2. **APP_FLOW.md**  
   すべてのページと、すべてのユーザーナビゲーション経路を平易な英語（＝自然文）で文書化する。各フローのトリガー。意思決定ポイントを含むステップ・バイ・ステップのシーケンス。成功時に何が起きるか、エラー時に何が起きるか。ルート（routes）付きの画面インベントリ。これがあると、AIが「ユーザーがどう移動するか」を推測しなくなる。

3. **TECH_STACK.md**  
   すべてのパッケージ、依存関係、API、ツールを、正確なバージョンまで固定する。曖昧さゼロ。AIに「Reactを使って」と言えば、AIはどのバージョンでも選び得る。だが「Next.js 14.1.0, React 18.2.0, TypeScript 5.3.3」と書けば、あなたが指定した通りに作る。このドキュメントは、幻の依存関係やランダムな技術選択を消す。

4. **FRONTEND_GUIDELINES.md**  
   完全なデザインシステム。フォント、正確なHEXコード付きカラーパレット、スペーシングスケール、レイアウト規則、コンポーネントスタイル、レスポンシブのブレークポイント、UIライブラリの好み。すべての視覚的意思決定をロックする。AIは作るすべてのコンポーネントでこれを参照する。ランダムな色や一貫しない余白はもう終わりだ。

5. **BACKEND_STRUCTURE.md**  
   すべてのテーブル、カラム、型、リレーションを定義したデータベーススキーマ。認証ロジック、APIエンドポイント契約、ストレージ規則、エッジケース。Supabaseを使うなら、ここに正確なSQL構造を含める。AIは自分の思い込みではなく、この設計図に従ってバックエンドを作る。

6. **IMPLEMENTATION_PLAN.md**  
   ステップ・バイ・ステップの実装シーケンス。「アプリを作れ」ではない。例えばこうだ：  
   step 1.1 プロジェクト初期化  
   step 1.2 TECH_STACK.mdの依存関係をインストール  
   step 1.3 フォルダ構成を作成  
   step 2.1 FRONTEND_GUIDELINES.mdに沿ってナビバーコンポーネントを作成  
   …という具合。ステップが多いほどAIは推測しない。推測が少ないほどハルシネーションも減る。

これらのドキュメントは相互参照する。PRDが機能を定義し、APP_FLOWがユーザー体験を定義し、TECH_STACKがそれを作る技術を定義し、FRONTEND_GUIDELINESが見た目を定義し、BACKEND_STRUCTUREがデータの動きを定義し、IMPLEMENTATION_PLANが構築順序を定義する。

これがあなたのナレッジベースだ。AIはこれを読み、必要なものをすべて手にする。

### 2つのセッションファイル（あなたの永続化レイヤー）

- **CLAUDE.md**  
  AIが毎セッション最初に自動で読むファイル。各AIセッションが必ず従うべきルール、制約、パターン、コンテキストが入っている。技術スタックの要約、ファイル命名規則、コンポーネントパターン、デザインシステムのトークン。許可されるものと禁止されるもの。あなたのプロジェクト専用の「AI運用マニュアル」だ。Claude Codeは、あなたが頼まなくてもプロジェクトルートからこれを読める。

- **progress.txt**  
  みんなが見落とすファイル。完了したこと、進行中のこと、次にやることを追跡する。機能を終えるたびに更新する。新しいセッションを始めるたび、新しいターミナルウィンドウを開くたび、ブランチを切り替えるたび、AIはまずこのファイルを読んで進捗の文脈記憶を得る。これがないと、新しいセッションは毎回「コンテキストゼロ」から始まり、道中に大量の大失敗（fuckups）を積む。これがあれば、AIはあなたが中断した場所から正確に再開する。

なぜ重要か：AIはセッション間の記憶を持たない。ターミナルを閉じたり、新しいものを開いたり、新しいチャットを始めたりすると、すべて消える。progress.txtはあなたの外部メモリだ。セッション間の橋になる。

宗教的に更新しろ。実装した機能が完了するたび、何を作ったか、何が動くか、何が壊れているか、次は何か――を緻密に記録しろ。

## 3: 尋問（Interrogation）システム

ドキュメントを書く前に、AIにあなたのアイデアを徹底的に解体させろ。

### すべてを変えるプロンプト

```text
コードを書く前に、Planningモードのみで私のアイデアを延々と尋問してください。何も仮定しないでください。前提が一切残らなくなるまで質問し続けてください。
```

AIは、あなたの「明確さ」が終わった地点でハルシネーションを始める。だから明確さを延長すれば、AIは壊れた土台の上に建て始める前に、あなたの思考の穴を見つけざるを得なくなる。

### AIがあなたに聞くべきこと

これは誰のため？ ユーザーが取るコアアクションは何？ そのアクションを完了したら何が起きる？ 保存すべきデータは何？ 表示すべきデータは何？ エラー時はどうなる？ 成功時はどうなる？ ログインは必要？ データベースは必要？ モバイル対応は必要？

これらに答えられないなら、あなたはまだ作る準備ができていない。先に答えを出せ。

良い尋問の例を示す。例えばレシピ共有アプリを作るとする：

これは誰のため？ レシピを保存して共有したい家庭の料理人。コアアクションは？ ユーザーがタイトル、材料リスト、手順、写真を含むレシピを作成する。次に何が起きる？ レシピはプロフィールに保存され、公開フィードに表示される。保存データは？ レシピタイトル、材料（配列）、手順（配列）、写真URL。

これらの答えは、ただの答えじゃない。カノニカルなMarkdownドキュメントの原材料だ。ユーザー説明はPRDに流れ、データ構造はBACKEND_STRUCTUREに流れ、フローはAPP_FLOWに流れ、モバイル要件はFRONTEND_GUIDELINESに流れる。

尋問が終わり、すべてに対する明確な答えが揃ったら、次はこの2つ目のプロンプトを使え。

### 尋問の内容に基づいて、カノニカルドキュメントを生成させる

- PRD.md
- APP_FLOW.md
- TECH_STACK.md
- FRONTEND_GUIDELINES.md
- BACKEND_STRUCTURE.md
- IMPLEMENTATION_PLAN.md

会話の回答をソース素材として使え。具体的に、網羅的に。曖昧さはゼロ。

AIは尋問結果から全ドキュメントを下書きする。あなたはそれをレビューし、曖昧な部分を直し、足りないものを追加し、「真実のソース」として固定する。

順番はこうだ：**尋問 → ドキュメント → コード**。そして、このステップを絶対に、絶対に、飛ばすな。

## 4: UI と UX

誰もが投げつけるのに、誰も簡単に説明しない2つの言葉がある。

UIは「見た目」（色、フォント、ボタン形状、余白）――つまり視覚レイヤー。UXは「使い心地」（何をすべきか分かるか？ フローは直感的か？ 人は詰まるか？ イライラするか、気持ちいいか？）。

美しいUIと最悪のUXは両立する。誰もクリック方法が分からない綺麗なボタンとか。

醜いUIと最高のUXも両立する。機能的で、明確で、何をすべきか誰でも分かる。でも見た目はひどい。

AIに話すときは、どっちの意味で言っているか具体的にしろ。「見た目を良くして」はUI。「使いやすくして」はUX。「ボタンをもっと分かりやすくして」は両方。

多くの人が知らない一手がある：スクリーンショットを参照として使うこと。好きなアプリやサイト（FramerやDribbbleでもいい）を見つけてスクショし、それをそのままClaude CodeやCursorに渡せ。プロンプトは「このレイアウトに合わせて」「このUIをそのまま再現して」「このUIを参考にして」など。AIは画像を解析し、デザインパターン、余白、カラーパレット、タイポグラフィ、コンポーネント構造をスクショから抽出できる。言葉でデザインを説明しようとするより、これは無限に良い。GoogleのGemini 3 Proは、いまのところ「プレミアム感のある見た目を一致させるデザイン」をさせる上で、私が見つけた中で一番のモデルだ。

自分の作業中の画面をスクショして、「今はこう見える。ここがダメ。直して」と言うのも同じくらい強い。視覚参照は、どんな文章よりも速く曖昧さを潰す。

さらに良い：Cursorには、デザインとコーディングを同時にできるブラウザサイドバーがある。アプリをライブでレンダリングした状態で見られる。要素をクリックして、動かして、色を変えて、レイアウトをテストして、CSSをリアルタイムに試せる。さらにAgentモード経由で、その変更をコードベースに直接適用できる。スクショ→貼り付け→待つ、のループ無しで視覚デザインを最速で反復できる。

### 知っておくべきデザインスタイル

いま支配的な「視覚言語」だ。FRONTEND_GUIDELINES.mdやAIへのプロンプトでこれらを参照すると、曖昧な説明ではなく、具体的で認識可能な美学をアンロックできる。

- **Glassmorphism**（グラスモーフィズム）  
  すりガラス効果。背景をぼかした半透明要素、控えめな境界線、柔らかい影が、カラフルな背景の上に浮かぶ。AppleのmacOS、Windows 11、Spotifyのモバイルアプリを思い浮かべろ。CSSなら `backdrop-filter: blur()` を使う。重い影に頼らずに奥行きと階層を作れる。高級感が出る。カード、モーダル、ナビバー、ダッシュボードに向いている。リスク：透明度は可読性を落とすので、テキストコントラストを高く保て。

- **Neobrutalism**（ネオ・ブルータリズム）  
  生々しく、太く、意図的に「整っていない」。高コントラスト、極太の黒い枠線、フラットな影、ケンカする配色、クセの強いフォント。Gumroadや初期Notionっぽい雰囲気。態度のあるミニマリズム。クリエイティブブランド、ポートフォリオ、インディーツールに合う。みんな同じに見える世界で目立つ。AIにはこう言え：「太い枠線と大胆な原色のネオブルータリズム」。

- **Neumorphism（Soft UI）**（ニューモーフィズム）  
  要素が背景から押し出されたり、押し込まれたりしているように見える。両側に柔らかく拡散した影を入れて、触感のある3D感を出す。繊細で上品だが、アクセシビリティ的に難しい。低コントラストでボタン判別が難しくなりがち。トグル、スライダー、カードなど、小さめのUI要素に向く。デザイン言語の全体としては相性が悪いことが多い。

- **Bento grid**（弁当グリッド）  
  コンテンツを、異なるサイズのブロックに並べるモジュラー・レイアウト。日本の弁当箱みたいな配置だ。Appleが普及させた。サイズの違うカードがリズムと階層を作る。重要な内容は大きいカード、二次情報は小さいカード。モバイルではグリッドが組み替わるので、レスポンシブに強い。ダッシュボード、プロダクトページ、機能紹介、ポートフォリオに最適。実用トレンドとしてはたぶん一番学ぶ価値がある。現実のレイアウト問題を解くからだ。

- **Dark mode**（ダークモード）  
  もはや「好みのトグル」ではなく、デザインシステムそのもの。暗い背景に明るいテキスト、丁寧なコントラスト比、彩度を抑えたアクセント。目の疲れを減らし、OLEDで電池を節約し、高級感が出る。消費者向けアプリを作るなら、最初からライト/ダーク両方を計画しろ。後から適当に足すな。FRONTEND_GUIDELINES.mdで両方のパレットとテーマを定義しろ。

- **Kinetic typography**（キネティック・タイポグラフィ）  
  動く・伸びる・スクロールやカーソルに反応する文字。入場アニメーションする見出し、スクロールでスケールするテキスト、インタラクティブなタイポ処理。単なるフェードインではない。現代のCSSとFramer Motionのようなライブラリなら、重いJavaScriptなしで実現できる。ヒーローセクションや、デザイン的に意味のある重要ポイントに限定して使え。

- **Micro-interactions**（マイクロインタラクション）  
  ユーザー操作に反応する小さなアニメーション。ホバーでわずかに拡大するボタン、クリックで弾むチェックボックス、生きている感じのローディングスピナー。こういう小さなディテールが、磨かれたプロダクトと、素人丸出しのプロダクトを分ける。インターフェースが「反応している」「生きている」「高級だ」と伝える。Framer MotionとCSSトランジションで簡単に扱える。

AIに頼むとき、「モダンにして」は言うな。「glassmorphismのカード、bento gridのレイアウト、ダークモード、ホバー状態にマイクロインタラクション」を言え。これは具体的で、作れる方向性だ。

コーディングを始める前に、FRONTEND_GUIDELINES.mdでデザインの意思決定をロックしろ。これらのスタイルから1〜2個選び、カラーパレット、スペーシングスケール、角丸、シャドウ値、アニメーションタイミングを定義しろ。ドキュメントが固ければ、AIは一貫して従う。ドキュメントがなければ、各コンポーネントは全部違う見た目になり、一貫性はゼロになる。

## 5: コンポーネント

コンポーネントは、再利用可能なUIの部品だ。

レゴを想像しろ。各ブロックがコンポーネントで、それらを組み合わせて何かを作る。

ボタンはコンポーネント。ナビゲーションバーもコンポーネント。商品カードもコンポーネント。フォームは、より小さなコンポーネント（入力、ラベル、ボタン）でできたコンポーネントだ。

### これがvibe codingで重要な理由

「ランディングページを作って」と言うと、AIはどんなコンポーネントを作るべきか自分で決めなければならない。あなたが指定しないなら、AIは推測する。結果、綺麗で再利用可能な部品ではなく、巨大な一枚岩のクソみたいな塊を作ることがある。

### より良いプロンプト

```text
次のコンポーネントでランディングページを作って：navbar、hero section、features grid（3枚のカード）、testimonial carousel、CTA section、footer。
```

これでAIは、作るべき部品を正確に理解する。各部品は分離され、各部品は独立して編集できる。これが「コンポーネント思考」の力だ。

## 6: レイアウト

レイアウトは、ページ上の「配置」だ。

すべてのWebサイトは「箱の中に箱」だ。これが概念だ。これをマスターすれば……

Webデザインの90%が分かる。

主要な箱：上にヘッダー/ナビバー、中にメインコンテンツ、隣に任意のサイドバー、下にフッター。

メインコンテンツの中にも箱がある：ページを分割するセクション、幅を制御するコンテナ、行と列で並べるグリッド、関連情報をまとめるカード。

### AIにレイアウトを説明するとき

2カラムレイアウト。左にサイドバー、幅250px。残りがメインコンテンツ。サイドバーは固定でスクロールしない。

これでレイアウト指示として完璧で、AIは何を作るべきか分かる。

## 7: ステート（State）

ステートは「変化するデータ」だ。

ボタンを押して何かが起きたら、ステートが変わった。フォームに入力して文字が表示されたら、ステートが変わった。ダークモードを切り替えて色が反転したら、ステートが変わった。

ステートがあるから、アプリは生きているように感じる。ステートがなければ全部静的だ。何も期待通りに反応しない。

よくあるステート例：メニューは開いている？閉じている？ ユーザーはログイン中？ログアウト中？ カートに何が入っている？ 入力欄のテキストは何？ ローディング中？完了？ 成功した？失敗した？

ボタンが何もしないとき、だいたいステート問題だ。クリックは起きた。でもアプリに「更新しろ」と言うものがない。

### AIにインタラクティブさを伝えるとき

ユーザーがこのボタンをクリックしたら、モーダルのステートを「open」にする。モーダル外をクリックしたら「closed」にする。

これでAIは、追跡すべきステートと、いつ変えるかを理解する。

## 8: スタイリング（Styling）

スタイリングは、見た目を良くすることだ。

CSSは見た目を制御する言語だ。色、余白、フォント、サイズ、位置。

Tailwindはショートカットシステムだ。CSSファイルを書く代わりに、要素にクラスを直接付ける。`bg-blue-500` は背景を青にする。`text-xl` は文字を大きくする。`p-4` はパディングを付ける。

デザイントークンは、再利用できる一貫した値だ。ブランドブルーは「適当な青」ではなく、どこでも同じHEXコード。余白はランダムではなく、常に4pxの倍数。角丸はすべてのカードで同じ。影は、浮いた要素なら同じ値。デザイントークンを使うことで、ハードコードされた色やUIハルシネーションを最小化できる。

これが、素人アプリと磨かれたアプリを分ける。すべてのコンポーネントが同じデザイントークンを使えば、アプリは統一感が出る。各コンポーネントが勝手に値を発明すれば、5人の別人が作ったみたいになる。

### コーディング開始前に、これを全部FRONTEND_GUIDELINES.mdへ固定しろ

primary / secondary / background / surface / text / borders / success / error / warning の正確なHEXコード付きカラーパレット。スペーシングスケール（4px, 8px, 12px, 16px, 24px, 32px, 48px, 64px）。見出し/本文/小文字のフォントサイズを含むフォントスタック。角丸の値。シャドウ定義。トランジションのタイミング。

AIがこのドキュメントを持てば、生成するコンポーネントは全部一致する。なければ、本来不要な不一致を手で直すのに何時間も溶かす。

信じろ、俺はそれを経験した。クソ面倒だ。避けろ。

スタイリング指示が具体的であるほど、AIは推測しない。「背景は#3B82F6で、パディング16px、角丸8pxにして」は、「青くして適当に余白入れて」より毎回勝つ。

## 9: レスポンシブデザイン

レスポンシブとは、すべての画面サイズでサイトが機能することだ。

ノートPCは広い。スマホは狭い。同じサイトでも、レイアウトは変わる。

大画面では列を増やす。小画面では縦に積む。大画面ではフルナビ。小画面ではハンバーガーメニュー。

ブレークポイントは、デザインが変化する画面幅だ。モバイルは0〜640px。タブレットは640〜1024px。デスクトップは1024px以上。

モバイルファーストとは、最小画面からデザインし、大きい画面で複雑さを追加することだ。Tailwindはデフォルトでこれ。プレフィックス無しのスタイルは全画面に適用される。`md:` や `lg:` のようなプレフィックス付きスタイルは、そのブレークポイントで初めて効く。だから `flex flex-col md:flex-row` は、モバイルでは縦積み、タブレット以上で横並びを意味する。

これは好みじゃない。戦略だ。モバイルファーストで作ると、内容、美観、ミニマリズムの優先順位付けを強制される。小さい画面に絶対に必要なものは何だ？ それがコアだ。それ以外は大画面向けの段階的強化（progressive enhancement）だ。そして小ささに縛られることで、体験を「簡単で、ミニマルで、ちゃんとセクシー」にする方向へ押し出される。

FRONTEND_GUIDELINES.mdで、ブレークポイントとレスポンシブパターンを定義しろ。例えばこうだ：  
「Navigation：768px未満はハンバーガー、以上は水平ナビ」  
「Grid：モバイル1列、タブレット2列、デスクトップ3列」  
「Font sizes：各ブレークポイントで15%ずつスケールアップ」  
AIがこれを文書化されたルールとして持てば、あなたが繰り返し指示しなくても、生成するコンポーネントはすべての画面サイズで正しく反応する。

常にモバイルファーストで考えろ。ユーザーの50%+はスマホかもしれない。ノートPCだけでテストするなら、多くのユーザーにとって壊れた体験を出荷することになる。


## 10: ページ（Pages）とルート（Routes）

ページはユーザーが見るもの。ルートは、そのページを表示するURLだ。

`yoursite.com/` はホームページ。`yoursite.com/about` はAboutページ。`yoursite.com/products/123` は商品123。

ルートは静的（`/about` は常に同じページ）にもできるし、動的（`/products/[id]` はidに応じて別の商品）にもできる。

### AIにアプリ構造を説明するとき

4ページ必要：home (`/`)、about (`/about`)、all products (`/products`)、single product (`/products/[id]`)

これでAIは全体構造を理解する。正しくリンクするナビゲーションを作り、正しい場所に正しいファイルを作る。

## 11: フロントエンド（Frontend）とバックエンド（Backend）

フロントエンドは、ユーザーが見て触るもの。ブラウザで動くインターフェース。

バックエンドは、裏側で起きること。データベース、ユーザーアカウント、処理、サーバー上で動くもの。

フォームを送信するとき：フロントエンドが入力を集める → サーバーへ送る → サーバーが検証して保存する → サーバーが確認を返す → フロントエンドが成功メッセージを表示する。

シンプルなサイトならバックエンドが不要なこともある。静的ページ、DBなし、アカウントなし。ユーザー、保存データ、複雑なロジックがあるアプリなら、両方が必要だ。

最初にAIへ「どっちが必要か」を言え。「フロントエンドだけ。ランディングページ」 vs 「ユーザーアカウントとDBを持つバックエンドが必要」では、出力が完全に変わる。

## 12: API

APIは、2つのシステムが会話する方法だ。

フロントエンドはバックエンドからデータが必要で、API経由で問い合わせる。アプリが天気データを要するなら、天気サービスのAPIに聞く。決済が必要なら、StripeのAPIに話しかける。

APIはウェイターだと思え。欲しいものを伝える。ウェイターが厨房へ行き、注文を持ってくる。

よくあるパターン：GETは取得、POSTは送信、PUTは更新、DELETEは削除。

### AIに話すとき

ページ読み込み時に `/api/products` へGETリクエストを送り、結果をグリッドで表示して。

これでAIは、何を作るべきか正確に分かる。

## 13: データベース（Databases）

データベースは、ものを永続的に保存する場所だ。DBがなければ、リロードした瞬間に全部リセットされる。ユーザーがサインアップ→リロード→消える。カートに追加→リロード→消える。

### 初心者向けのよくある選択肢

Supabaseが一番簡単なスタートだ。

無料枠があり、ドキュメントも良く、認証も扱える。何を使うか迷うならSupabaseにしろ。

DBが必要なのはいつ？ ユーザーがアカウントを作る。ユーザーが自分のコンテンツを保存する。投稿や送信内容を保存する。データが時間とともに増える。

不要なのはいつ？ 静的サイト。全員同じ内容のポートフォリオ。ユーザー操作がない。フォームサービス経由でメールだけ集めるランディングページ。

### AIに話すとき

Supabaseを使う。`users`テーブルにemailとpassword、`posts`テーブルにtitle, content, user_idが必要。

これでAIはデータ構造を理解し、それに合わせて全部作れる。

## 14: 認証（Authentication）

認証はログイン/ログアウト――つまり「誰であるかを証明すること」。

見た目より難しい。パスワードは暗号化が必要。セッションは管理が必要。トークンは扱いが必要。失敗しやすい。

認証をゼロから作るな。サービスを使え。Clerkは、最初からUIが良くて一番簡単。SupabaseをDBに使っているなら、Supabase Authも動く。

### AIに話す例

認証はClerkを使う。ユーザーはメールまたはGoogleでサインアップできる。ログイン後はダッシュボードにリダイレクトする。

難しい部分はサービスに任せて、あなたは接続するだけにしろ。

## 15: ファイルタイプ（File Types）

コードベースには大量のファイルがある。いくつかはこういうものだ：

`.html` はWebページの構造。`.css` はスタイル規則。`.js` はインタラクティブさを作るJavaScript。`.jsx` はReact向けのHTMLっぽい構文を含むJavaScript。`.ts` は型でエラーを捕まえるTypeScript（＝型付きJavaScript）。`.tsx` はReact向けTypeScript。`.json` は構造化データ。`.md` はMarkdown（整形されたテキスト）。`.env` は環境変数とシークレット。`.gitignore` はgitが無視するファイルを指定する。

重要なのは `.env` だ。ここにAPIキー、シークレット、パスワードを入れる。絶対に共有するな。絶対にgitへコミットするな。絶対にスクショするな。`.env` を漏らすと、すべてへのアクセスを漏らすことになる。運の良いクズ（degenerate）があなたのAPI請求を数千ドルに膨らませる。そんなミスをするな。

## 16: フォルダ構成（Folder Structure）

ファイルの置き場所は重要だ。

散らかったプロジェクトはAIを混乱させる。

### 標準構成

```text
my-app/
├── src/
│   ├── app/                 → pages と routes
│   ├── components/          → 再利用可能UI部品
│   ├── lib/                 → ユーティリティ、ヘルパー
│   └── styles/              → CSSファイル
├── public/                  → 画像、静的ファイル
├── .env                     → シークレット（絶対共有しない）
├── CLAUDE.md                → AIのルールとコンテキスト
├── progress.txt             → セッション進捗トラッキング
├── PRD.md                   → 要件
├── APP_FLOW.md              → ユーザーフローとナビ
├── TECH_STACK.md            → 固定された依存関係
├── FRONTEND_GUIDELINES.md   → デザインシステム
├── BACKEND_STRUCTURE.md     → DBとAPI仕様
├── IMPLEMENTATION_PLAN.md   → 手順付きビルド順序
├── package.json             → 依存関係
└── README.md                → プロジェクト概要
```

AIにコード生成させるときは、どこに置くかを言え。例：「ボタンコンポーネントを `src/components/Button.tsx` に作って」。指定しないと、AIはどこにでもファイルを置き、何も繋がらないことがある。

## 17: 実運用としてのドキュメントシステム

Markdownは任意じゃない。

AIが考える言語だ。

あなたが書く `.md` はすべて、AIが読んで理解し、従える参照ドキュメントになる。これがドキュメント・ファーストが機能する理由だ。あなたは人間のためにドキュメントを書いているんじゃない。

AIのための制約を書いている。

### ビルド中に、各カノニカルMarkdownがどう使われるか

**PRD.md** はスコープの真実のソースだ。AIが頼んでいない機能を足そうとしたらPRDへ戻せ。「PRD.mdにあるものだけ作れ」。次に何を作るか決めるときもPRDを見る。スコープクリープを、始まる前に殺す。

**APP_FLOW.md** はページ遷移とユーザージャーニーを作るときに参照する。「APP_FLOW.mdのセクション3にある通りにログインフローを作れ」。AIは、そのフロー内の全画面、全リダイレクト、全エラーステートを理解する。

**TECH_STACK.md** はプロジェクト初期化時と、AIが新しい依存関係を入れようとするときに参照する。「TECH_STACK.mdにあるパッケージだけ使え。新規依存を追加するなら必ず先に聞け」。勝手なライブラリ導入を防ぐ。

**FRONTEND_GUIDELINES.md** はAIが作る全コンポーネントの参照ドキュメントだ。色、余白、タイポグラフィ、コンポーネントパターン、レスポンシブ規則。「セクション2に従ってスタイルして」。全ファイルでデザインが揃う。

**BACKEND_STRUCTURE.md** はデータ層を定義する。「セクション2.1の通りにusersテーブルを作れ」。AIはあなたが指定したスキーマを正確に作り、自己解釈しない。

**IMPLEMENTATION_PLAN.md** は実行順序だ。「IMPLEMENTATION_PLAN.mdのstep 4.2にいる。このステップだけ作れ」。AIが先走ったり、順序を飛ばすのを防ぐ。

**CLAUDE.md** はマスター設定ファイルだ。プロジェクトルートに置き、Claude Codeは毎セッション自動で読む。6つのドキュメントの凝縮ルール（技術スタック要約、命名規則、ファイル構造、コンポーネントパターン、禁止事項）を含む。AIが何かする前に読み込む「OSマニュアル」だと思え。

多くの人が見落とす一手：**CLAUDE.mdは生きたドキュメント**だ。AIがミスをして、あなたが修正したら、最後に必ずこう言え：「そのミスを二度としないように、CLAUDE.mdを編集して」。Claudeは自分のためのルールを書くのが不気味なほど上手い。時間が経つほどCLAUDE.mdは自己改善するルールブックになり、ミス率は目に見えて下がる。AIが文字通り、自分の修正をルールとしてエンコードしていくからだ（理想的には、まさに起きてほしいこと）。

さらに `lessons.md` を足せ。各修正、各PR、各デバッグセッションの後で、Claudeが「問題を起こしたパターン」と「それを防ぐルール」をlessons.mdに追記する。CLAUDE.mdから参照させろ：「セッション開始時にlessons.mdを確認し、該当ルールを適用せよ」。これでAIはプロジェクト上の自分の履歴から学ぶ。この自己改善ループが、良いCLAUDE.mdと偉大なCLAUDE.mdを分ける。

### CLAUDE.mdの例

```text
Tech stack: Next.js 14, TypeScript, Tailwind CSS, Supabase
All components go in src/components/
Use functional components with hooks
All API routes go in src/app/api/
Never use inline styles. Always use Tailwind.
Design tokens: primary blue #3B82F6, background #F9FAFB
Mobile-first responsive approach
Reference docs: PRD.md, APP_FLOW.md, TECH_STACK.md, FRONTEND_GUIDELINES.md, BACKEND_STRUCTURE.md, IMPLEMENTATION_PLAN.md
Read progress.txt at the start of every session.
Update progress.txt after completing any feature.
Review lessons.md at session start.
Update it after every correction.
```

Claude Codeがこれを読むと、作るすべてのファイルでこれらのルールに従い、ドリフト（逸脱）もランダムな意思決定もなくなる。純粋な一貫性だ。

Cursorにも同じ概念がある：`.cursor/rules` ファイル。概念は同じで、ツールが違うだけ。プロジェクトルールを `.cursor/rules/` に置けば、Cursorは全モードで自動的に読む。CursorとClaude Codeの両方を同じプロジェクトで使うなら、CLAUDE.mdとCursorルールを揃えろ。同じ制約、同じ規約、同じ真実のソースだ。片方を維持してもう片方にコピーする人もいる。共有ルールファイルを作って両方から参照する人もいる。どっちでもいい。要は、コードベースに触るすべてのAIツールが同じルールに従うこと。

progress.txtはセッションの橋だ。機能ごとに更新しろ：

```text
COMPLETED: Clerkによるユーザー認証（login / signup / Google OAuth）
ダッシュボードのレイアウト（サイドバー・ナビ付き）
Products APIエンドポイント（GET /api/products）
IN PROGRESS: 商品詳細ページ（/products/[id]）
フロントエンドとAPIの接続が必要
NEXT: ショッピングカート機能
Stripeでチェックアウト
KNOWN BUGS: リンクをクリックした後、モバイルナビが閉じない
```

新しいターミナルを開く、Claude Codeの新セッションを始める、ブランチを切り替える、1週間後に戻ってくる――そのたびにAIはこれを読んで、あなたがどこにいるか正確に分かる。「何やってたっけ？」はない。ゼロからコンテキストを組み直すこともない。69回目にプロジェクト全体を再説明する地獄もない。

これがシステムだ。カノニカルドキュメントが「何を作るか」を定義し、CLAUDE.mdがルールを強制し、progress.txtがセッション間の状態を保存する。3つが揃えば、AIはハルシネーションせずにプロジェクトを作るのに必要なものをすべて持てる。

Markdownドキュメントが多いほど、AIは推測しない。推測が少ないほど、あなたはうまくいく。


## 18: ツールと使い分け

ツールは50個も要らない。必要なのはこれだけだ。だが、正しく使え。ビルドのフェーズごとに使うツールが違う。

### Cursor（コードエディタ）

AIネイティブで、このワークフローのために作られた。プロジェクト全体が見え、ファイル間の関係を理解し、複数ファイルをまたいで編集できる。

でもCursorは1つの機能じゃない。4つのモードがあり、ほとんどの人は1つしか使っていない：

- **Ask mode（読み取り専用）**  
  AIがコードベースを読み、何も変更せずに質問に答える。知らないコードを探索するとき、仕組みを理解したいとき、ファイルに触る前に次の一手を考えるときに使え。コードコンサルタントだと思え。  
  例：「この関数は何をしてる？」  
  例：「なぜこのコンポーネントは再レンダリングする？」  
  例：「このスキーマを変えたら何が壊れる？」  
  Ask modeは、行動の前に考える場所だ。

- **Plan mode（設計）**  
  コードを書く前にアーキテクトするモード。作りたいものを説明すると、Cursorがステップ付きの詳細な実装計画を作り、確認質問をし、アプローチの図解も生成できる。新機能の開始時に必ず使え。  
  例：「このアプリにStripeチェックアウトを追加したい。計画を作って。」  
  計画をレビューし、調整し、ステップを承認してから、そのステップをAgent modeに渡して実行させろ。

- **Agent mode（実装の主力）**  
  AIが自律的にコードを書き、ファイルを編集し、ターミナルコマンドを走らせ、パッケージをインストールし、エラーを直す。プロジェクト全体を読み、ルールファイルに従い、機能をエンドツーエンドで実装する。  
  「ダッシュボードページを作って」と言ったときに実作業をするのがここだ。vibe codingの大半はここで起きる。

- **Debug mode（構造化デバッグ）**  
  多くの人が知らないモード。頑固なバグに当たったとき、Debug modeはランダムな修正を試さない。実行時ログで計測し、複数の仮説を立て、再現を求め、修正をテストし、あなたに検証を促す。エディタ内に組み込まれた構造化デバッグループだ。

Cursorのワークフロー：**Askで理解 → Planで設計 → Agentで実装 → 壊れたらDebug**

### Claude（Claude.ai / Claude Code）

Claudeは思考パートナーだ。重い思考に使え：アイデアの尋問、6つのカノニカルドキュメント作成、アーキテクチャ計画、複雑なプロダクト判断、CLAUDE.mdのドラフト。Claudeは、後続のすべてに栄養を与える「聞く/計画する/書く」をやる場所だ。

Claude Codeはターミナルで動き、プロジェクトルートのCLAUDE.mdを毎セッション自動で読む。あなたが繰り返しルールを言わなくても従う。大きなリファクタ、ドキュメント中心の作業、複数ファイルに渡るアーキ変更では、Claude Codeが最強だ。

### Kimi K2.5

Moonshot AIのオープンソース「ビジュアルコーディング」モデル。フロントエンド実装の専門家だ。K2.5はネイティブなマルチモーダルモデルで、視覚とテキストを最初から統合して学習している。スクリーンショット、動画、デザインモックを与えると、見た目に非常に近い機能的なフロントエンドコードを生成する。レイアウト、アニメーション、インタラクション、レスポンシブ挙動。ほかのモデルがデザインを「それっぽく」近似するのに対し、K2.5は再現する。  
デザインをコードに翻訳するとき（Kimi Code経由、またはCursorのモデルセレクタで）Kimi K2.5を使え。FRONTEND_GUIDELINES.mdでシステムを定義し、スクショで参照を与え、ピクセル精度の実装が必要なら――それがK2.5の担当領域だ。

### Codex

OpenAIのコーディングエージェント。デバッガー兼フィニッシャーだ。Codexはクラウドで動き、Codex CLIでターミナルから、またはIDEから直接使える。各タスクはリポジトリがプリロードされた隔離サンドボックスを持つ。

Codexが違うのはデバッグのやり方だ。コードベースを読み、依存関係を辿り、設定をレビューし、複数ファイルに跨る修正案を出す。テストを実行し、失敗を直し、すべて通るまで反復できる。

ファイルとアーキテクチャが出来上がった後にCodexを使え。構造はあるが壊れているとき、出荷前のコードレビューが欲しいとき、既存機能を壊さずにリファクタしたいとき、見落としたバグを見つけてほしいとき。Codexはクロージャーだ。複数のCodexタスクを別々のバグ/機能に並列で走らせることもできる。非同期で動く。タスクを開始して、別のことをして、戻って結果をレビューする。

### マルチツール・ワークフロー

- Claudeが思考する。ドキュメントを書き、アーキを計画し、プロダクト判断をする。ここが「聞く/計画する/考える」場所。
- Cursor Agent mode（またはClaude Code、またはKimi K2.5）が実装する。計画から機能を実装し、コンポーネントを作り、フロントとバックを繋ぐ。作業に応じてモデルを選べ：
  - 見た目重視のフロントエンド：K2.5
  - アーキ/ドキュメント重視：Claude Code
  - 一般的な実装：Cursor Agent
- Codexがデバッグと仕上げをする。組み上がったコードベースに当て、バグを見つけ、失敗を追跡し、レビューし、修正案を出し、テストが通るまで回す。そこから綺麗に出荷する。

### GitHub

コードがクラウドに置かれ、バージョン管理で全変更が追跡される。過去バージョンへ戻せる。壊したら元に戻せる。スタックに対して交渉不可（必須）だ。

### Vercel

デプロイのための場所。GitHubへプッシュすれば、Vercelが自動でビルド＆デプロイする。ライブURLが出る。無料枠も太い。あなたのPCからインターネットへ、数分で出せる。

### Supabase

DBと認証のための場所。無料枠があり、セットアップも簡単。バックエンドの面倒を扱ってくれるので、あなたはプロダクトに集中できる。

これらのツールをマスターしろ。いつ何を使うかを理解しろ。「どのAIモデルを使うか」ではなく、「いつどのAIモデルを使うか」が、出荷できる人と詰む人の差だ。

## 18.5: 上級ワークフロー（準備ができたら）

この基本システムでいくつかプロジェクトを作ったら、速度を倍増させるテクニックがある。これはClaude Codeを仕事で作っている人たちから直接出てきたものだ。

- **git worktreesによる並列セッション**  
  最大の生産性アンロック。1つずつやる代わりに、3〜5個のgit worktreeを作り、それぞれでClaude Codeセッションを並列実行する。あるworktreeは認証、別はダッシュボードレイアウト、別はAPIエンドポイント。全員同じリポジトリを共有しつつ、独立して作業する。あなたは行き来して、出力をレビューし、変更を承認し、終わったらマージする。1日かかった逐次ビルドが、数時間の並列実行になる。worktreeに名前を付け、シェルエイリアスを用意して、ワンキーストロークで飛べるようにしろ。

- **Plan modeをフォースマルチプライヤにする**  
  CursorのPlan modeを使うのはもう分かってるはずだ。さらに強くする方法：1つのClaudeセッションで計画を書き、2つ目のセッションを立ち上げて、スタッフエンジニアとして計画レビューさせろ。  
  例：「この実装計画をレビューして。抜け、見落としたエッジケース、壊れる点を探して。」  
  コードを1行も書く前に計画を直す。実装中に何かがおかしくなったら即停止。押し切るな。Plan modeへ戻って、現在地から再計画しろ。Plan modeはビルドだけでなく検証にも使える。  
  例：「この認証フローがすべてのエッジケースを扱えているか検証する計画を立てて。」

- **複雑問題にはSubagents**  
  1つのClaudeセッションがコンテキストで窒息するほど大きい問題なら、subagentsを使え。依頼文に「use subagents」を付けると、Claudeが調査・探索・並列分析のための集中サブセッションを立ち上げつつ、メインセッションのコンテキスト窓を綺麗に保つ。サブエージェントは1タスク1つ。自分一人でやるのではなく、チームに委任する感覚だ。

- **カスタムスキルとスラッシュコマンド**  
  1日に複数回やることは、再利用スキル/スラッシュコマンドにしてgitへコミットしろ。例えばセッション終わりに重複コードを検出して潰す `/techdebt` コマンド。直近1週間のSlack/Docs/GitHub活動を1つにダンプして、Claudeが毎セッション完全情報で始められる `context-sync` コマンド。スキルは、あなたのワークフロー専用の能力をClaudeに教える方法だ。プロジェクトを触るたびに複利で効く。

- **自律的なバグ修正**  
  デバッガーを手取り足取りするのをやめろ。バグ報告を受けたら貼って「fix」。CIが落ちたら「落ちてるCIテストを直せ」。やり方は説明するな。ログ、スタックトレース、失敗テストへポインタを出すだけ。Claudeに問題を辿らせ、根本原因を見つけさせ、解決させろ。あなたのコンテキストスイッチはゼロ。ClaudeはDockerログを読んだり、分散システムを辿ったり、手作業で何時間もかける修正を意外なほどこなす。

- **音声入力でプロンプト品質を上げる**  
  話す速度は打つ速度の3倍で、結果としてプロンプトが劇的に詳細になる。macOSならfnキーを2回押してディクテーション開始。タイピングが遅いせいで普段省略するニュアンスや文脈まで、会話的に説明しろ。長く詳細なプロンプトは、より良い出力を作る。音声はそこへの近道だ。

- **学習モード**  
  AIにやらせるだけでなく、AIが何をしているか理解したいなら、Claude Codeの設定で「Explanatory」や「Learning」出力スタイルを有効にしろ。Claudeは各変更の理由を説明する。知らないコードを説明する視覚HTMLプレゼンを生成させたり、アーキテクチャ/プロトコルをASCII図で描かせたり、新概念から間隔反復フラッシュカードを作らせたりもできる。作りながら学ぶ人が、最終的にこのガイドを必要としなくなる。

## 19: Git とバージョン管理

Gitは、あなたが行うすべての変更を追跡する。

Gitなし：何かを壊しても戻せない。何が変わったか追えない。1回のミスで全部を破壊できる。

Gitあり：すべての変更が保存される。どの過去バージョンにも戻せる。コードはPCだけでなくGitHubに住む。

### 基本

- `git add .` で変更をステージ
- `git commit -m "message"` で変更を説明付きで保存
- `git push` でGitHubへアップロード
- `git pull` で最新をダウンロード

vibe codingをするなら、コミットは頻繁に。動く主要機能ごとにコミットしろ：「Added user login」「Added product grid」「Fixed checkout bug」。壊したら戻せる。

これはprogress.txtシステムにも繋がる。コードをコミットし、progress.txtを更新し、両方プッシュする。これでGitHubにコードとコンテキストファイルが残る。次のセッションでpullして、progress.txtを読んで、続きから進める。

## 20: 環境変数とシークレット

APIキー、DBパスワード、シークレットは、公開/本番コードベースに絶対に入れるな。

`.env` ファイルに入れる。そしてコード側から参照する。

`process.env.YOUR_KEY_NAME` 経由でアクセスする。

ルール：`.env` をgitへコミットするな（`.gitignore` に入れろ）。AIアプリのチャットやスクショにAPIキーを貼るな。やったら「漏れた」と思え。シークレットをフロントエンドコードに入れるな（バックエンドだけ）。開発用と本番用でキーを分けろ。

Vercelへデプロイするときは、Vercelのダッシュボード設定で環境変数を追加する。ローカルの `.env` は自動で移行されない。

キーを漏らしたら、即そのサービスで失効（revoke）しろ。そして新しいキーを作れ。

## 21: デプロイ（Deployment）

あなたのPCで動くコードを、インターネットで動かす必要がある。

### Vercelでの流れ

- GitHubへプッシュ
- GitHubリポジトリをVercelに接続
- Vercelが自動でビルド＆デプロイ
- `your-app.vercel.app` のようなURLが手に入る
- Vercelのダッシュボードで環境変数を設定

ローカルでは動くのにデプロイで壊れるなら、AIにVercelのエラーログを渡せ。  
「localhostでは動くが、Vercelでは壊れる。Vercelログのエラーはこれ：」と書いて、エラーを貼れ。

デプロイバグの99%は、ENV変数の不足か、ビルド設定のミスだ。

## 22: エラーメッセージの読み方

エラーは侮辱じゃない。指示書だ。

エラーメッセージは「何が間違ったか」を正確に言っている。多くの人はパニックになって無視する。頼むからやめろ。

### エラーの解剖

```text
TypeError: Cannot read property 'map' of undefined
at ProductList (src/components/ProductList.tsx:15:23)
```

翻訳：TypeErrorは「使い方が間違っている」を意味する。`Cannot read property 'map' of undefined` は「存在しないものに `.map()` を使おうとした」。`ProductList.tsx:15:23` は、ファイルと行番号を教えている。

### エラーが出たら、AIに全部渡せ

「このエラーが出てる：[フルのエラーメッセージ]。その行のコードはこれ：[該当箇所を貼る]」

エラーに関するコンテキストを多く渡すほど、解決が速くなる。

## 23: デバッグループ

### 壊れたら

- エラーを読む。ちゃんと読む。
- 場所を特定する。どのファイル、どの行。
- 主張を理解する。エラーは何が悪いと言っている？
- ありがちな原因を潰す。タイポ、import漏れ、変数名の間違い。
- AIへ文脈を渡す。エラー + コード + 期待していた挙動。

ループはこうだ：AIがコードを出す → あなたが試す → 壊れる → エラーを貼る → AIが直す → 動くまで繰り返す。

2〜3回このループを回しても死なない頑固なバグなら、ツールを切り替えろ。CursorのDebug modeを使え。複数仮説を作り、実行時ログを入れ、推測ではなく方法論で辿る。あるいはCodexを起動し、バグの説明を渡して、コードベース全体を辿らせ、複数ファイルに跨る根本原因を特定させ、テストが通るまで反復させろ。Codexは、複数ファイルに跨るバグや、データフロー問題に特に強い。修正案を出す前にリポジトリ全体を読むからだ。

これは普通だ。vibe codingは、一発で終わるものとして語られがちだが、一般にそうはならない。反復だ。スキルは、反復を速く回し、状況に応じて正しいツールを選ぶことだ。反復そのものを避けることじゃない。


## 24: 出荷前の検証

### 出荷前にチェックしろ

- モバイルで動くか？ 実際にスマホで開け。
- 別ブラウザで動くか？
- データが空のときはどうなる？ 空状態（empty state）は処理されているか？
- データが間違っているときはどうなる？ エラーステートは処理されているか？
- 回線が遅いときはどうなる？ ローディングステートはあるか？
- 連打で壊せるか？
- シークレットはブラウザのDevToolsから見えないか？

これらに答えるまで出荷するな。ユーザーは、あなたが見逃したバグを全部見つける。

このプロセスを徹底的にやれ。

## 25: これらすべてをAIにどう伝えるか

語彙を手に入れたなら……使え。

### 曖昧なプロンプト

ユーザーが投稿できるアプリを作って

### ドキュメントに裏打ちされた具体プロンプト

最初にCLAUDE.mdとprogress.txtを読んで。次にIMPLEMENTATION_PLAN.mdのstep 4.2を実装して。ログインフローはAPP_FLOW.mdのセクション3に定義してある。認証設定はBACKEND_STRUCTURE.mdのセクション5を使って。スタイルは全部FRONTEND_GUIDELINES.mdに従って。UIは添付スクリーンショットに合わせて。

同じアイデアでも、

出力品質は別物になる。

具体性は「余計な作業」じゃない。具体性こそが「作業そのもの」だ。最初に定義するほど、あとでデバッグしなくて済む。

## 26: AIの出力の読み方

AIがコードを作った。あなたは今、何を見ているか分かるか？

すべての行を理解する必要はない。だが構造は理解しろ。どのファイルが作られた？ それぞれは何をする？ どう繋がる？

AIがコードを生成したら、こう聞け：  
「今作ったものを平易な英語で説明して。各ファイルは何をする？ どう繋がる？」

時間が経つとパターンが見えてくる。`import` を見て「別ファイルから引いている」と分かる。`useState` を見て「変化するものを追跡している」と分かる。API呼び出しを見て「データを取っている」と分かる。

これが、vibe coderから「実際に作れる人」へ変わる方法だ。構文を暗記することではない。パターンを理解することだ。

## 27: 反復（Iteration）のやり方

最初の出力が正しいことはほぼない……でもそれでいい。

### 反復システム

- AIがバージョン1を作る
- あなたがテストして、何が間違っているか見つける
- 何が間違っているかを具体的に説明する（「壊れてる」ではなく、「送信ボタンがDBに保存しない。これがエラー」）
- AIが直す
- あなたが再テストする
- 繰り返す

良い反復：  
「商品グリッドがデスクトップで4列になっているが3列にしたい。カード画像が伸びているので `object-cover` にしてほしい。データ取得中のローディングステートがない。」

悪い反復：  
「なんか違う。直して。」

具体的に。常に。

## 28: 大きなアイデアを小さく切る

AIは、大きくてふわっとした依頼で窒息する。「フルのECサイトを作って」は、だいたい絶対的なゴミを吐く。

### 小さく分けろ

- プロジェクトの雛形を作り、依存関係を入れる
- ナビバーコンポーネントを作る
- 商品カードコンポーネントを作る
- 商品グリッドページを作る
- DBに接続して商品を取得する
- 商品詳細ページを作る
- カート追加機能を作る
- カートページを作る
- Stripeでチェックアウトする

各ピースは、1回の会話または1タスクだ。

各ピースは前のピースの上に積み重なり、各ピースは独立してテストできる。レゴ時代に戻れ。実際にそれだ。

これは、あなたのIMPLEMENTATION_PLAN.mdそのものだ。上のリストを番号付きで順序立てたのが実装計画の形式だ。パート2の作業をやっていれば、あなたはすでにこれを書いている。コーディング中にその場で作らない。始める前に作った。今は計画に沿って、ステップ・バイ・ステップで実行しているだけだ。

AIにはこう言え：「IMPLEMENTATION_PLAN.mdのstep 5を作れ」。  
「次を作れ」じゃない。精度は複利で効く。

これはprogress.txtにも繋がる。各ピースの後に進捗を更新する。

次のピースは新鮮なコンテキストで始めろ。

## 29: AIが間違ったツールであるとき

ときどき、ただ「学ぶ」必要がある。

AIはこういう用途に使え：ボイラープレート生成、反復的ロジック作成、アプローチの高速探索、文脈付きデバッグ、意図をコードへ翻訳。

自分で学べ：コア概念（このガイドの全部）、AIが作ったコードの読み方、AIが間違っていると気づく方法、AIでも助けられないときのデバッグ方法、そして選んだスタックの基本。

AIに全部依存するなら、あなたは流砂の上に建てている。変なバグが1つ来たら、詰んで沈む。AIが何かを間違って説明し、あなたがそれを信じたら……マジで終わる。だから多分、今これを学べ。

あと：Webの公式ドキュメントの方がAI情報より良いことが多い。Stack Overflowにはエラーへの正確な答えがある。ドキュメントサイトには権威ある情報がある。AIは統合と生成に強いが、失敗したときに公式ドキュメントを検索する能力がフォールバックで、誰も語らないスキルだ。そしてClaudeは、そういう一次情報から自己学習することすらできる。

## 30: スコープと、止め時を知る

終わりのない機能リストは、少し悪いコードより多くのプロジェクトを殺す。

あなたが「終わり」なのは、コア機能が動き、ユーザーが主要アクションを完了でき、一般的な経路で壊れず、デプロイされ、アクセス可能なときだ。

「完璧」になったときじゃない。  
「すべてのエッジケースを扱った」「想像した全機能がある」「Dribbbleのデザインと完全一致」――それは終わりではない。

シンプル版を出荷してフィードバックを取れ。そこから実使用に基づいて改善しろ。

出荷しない最高のアプリは、ライブになっている平均的なアプリより悪い。

## 31: 作ったものを保守する

### 作った。そして次は変える必要がある

未来のあなた（またはAI）がコードを理解する必要がある。ここでドキュメントシステムが本領を発揮する。

READMEはプロジェクトが何かを説明する。CLAUDE.mdはルールを強制する。progress.txtは何が作られ、次が何かを示す。カノニカルなMarkdownドキュメントは、要件から実装順序まで、プロダクトのすべてを定義する。

### 3か月後にコードへ戻るとき

```text
最初にCLAUDE.md、progress.txt、PRD.mdを読んで。しばらく休んだあと、このプロジェクトに戻ってきた。IMPLEMENTATION_PLAN.mdに照らして現状を要約し、注意が必要な点を教えて。
```

良いドキュメントは、未来のvibe codingセッションを10倍速くする。悪いドキュメントは、ゼロからやり直しだ。

依存関係を更新し、分かりにくい部分にコメントを書き、命名を一貫させ、あなたのコードベースを「Airbnbで見ず知らずの人が泊まって、どこに何があるか知る必要がある家」だと思って扱え。

## 32: コスト意識

APIコールは金がかかる。DBもかかる。ホスティングもかかる。AIツールもかかる。

無料枠は存在し、しかも太い。Vercelは無料、Supabaseは無料、Clerkも（制限内で）無料、など。ただしスケールするとコストは出る。

AIツールのコスト：Cursor Proがモデルアクセスの大半をカバーし、主サブスクになる。Claude Codeの利用はAnthropicやClaudeプラン経由。CodexはChatGPT Plus/Pro以上の層に含まれる。Kimi K2.5はオープンソースで、Kimi.com経由の無料アクセスや、比較的寛容なAPI価格がある。初日からすべての有料ティアは要らない。Cursor ProとClaude（またはGemini Pro 3）から始めて、必要になったら増やせ。

何が無料で、何が積み上がるかを知れ。AI API（OpenAI、Anthropic）はトークン課金。DBストレージは無料枠を超えると課金。画像ホスティングは規模で課金。

最初は無料で始めろ。必要になったらスケールしろ。初日から「数百万ユーザー」を前提に設計するな。

現実として、たぶんそこまで行かない。小さく始めろ。

## 33: セキュリティの基本

### 最低限

- APIキーをフロントエンドコードに絶対に出すな。
- バックエンドで必ず入力検証しろ（ブラウザから来たものを信じるな）。
- HTTPSを使え（Vercelは自動でやってくれる）。
- 依存関係を更新しろ（古いパッケージには既知の脆弱性がある）。
- 認証は自作せずサービスを使え。

あなたは高セキュリティ銀行を作っているわけじゃない。でも、当たり前の脆弱性を抱えたアプリを出荷しないために、最低限のセキュリティは知っておけ。

そしてネットで笑い者にされないために。多くの人の最悪の悪夢だ。

## 34: サードパーティサービス

すべてをゼロから作るな。

難しい部分はサービスで差し込め。

- 認証：Clerk、Supabase Auth（login / signup / sessions）
- 決済：Stripe（お金）
- データベース：Supabase、Firebase（保存）
- メール：Resend、SendGrid（トランザクションメール）
- ファイルアップロード：Uploadthing、Supabase Storage（メディア）

いつサービスを使うべきか：その機能があなたのコアプロダクトではないとき。コアプロダクトは、あなたが作るユニークな部分だ。その他はインフラだ。インフラは既存サービスを使え。

## 35: アセット、メディア、コンポーネントライブラリ

画像、フォント、アイコン、プリビルドのコンポーネント。どこで手に入れ、どう使うか。

- アイコン：Lucide React（無料、一貫していて使いやすい）
- フォント：Google Fonts（レイアウトにインポートして全体で使う）
- 画像：Unsplash（ストック）、自前（商品写真）、AI生成（カスタム）

ファイルサイズは重要だ。巨大画像はサイトを遅くする。アップロード前に圧縮しろ。Next.jsのImageコンポーネントで自動最適化しろ。

コンポーネントライブラリは、初心者が知らないチートコードだ。ボタン、モーダル、ドロップダウン、フォーム要素を全部自作する代わりに、磨かれていて、アクセシブルで、カスタマイズ可能なコンポーネントを最初から持つライブラリを使え。

`shadcn/ui` は、Next.js + Tailwindのエコシステムで今の支配的選択だ。依存関係としてインストールする伝統的なライブラリではない。コンポーネントのソースコードをあなたのプロジェクトに直接コピーする。つまり、あなたがコードを所有し、全部カスタマイズできる。ボタン、ダイアログ、ドロップダウン、タブ、フォーム、データテーブル――すべてRadix UIのプリミティブを土台に、Tailwindでスタイリングされている。AIにはこう言え：  
「shadcn/uiコンポーネントを使って。`npx shadcn@latest init` で初期化して、必要なコンポーネントを追加して。」  
これで基本UIを作る時間を何時間も節約でき、最初からアクセシブルで本番品質の部品が手に入る。

コンポーネントライブラリの選択は、TECH_STACK.mdとFRONTEND_GUIDELINES.mdに書いて固定しろ。そうすればAIは全ページで一貫して使う。

## 完全なシステム（The Complete System）

あなたはもう全部持っている。

### 作る前に

- 尋問プロンプトを走らせろ。AIにあなたのアイデアを残酷に尋問させろ。
- AIが聞く質問に全部答えろ。
- ドキュメント生成プロンプトで、6つのカノニカルドキュメントを作れ：PRD.md / APP_FLOW.md / TECH_STACK.md / FRONTEND_GUIDELINES.md / BACKEND_STRUCTURE.md / IMPLEMENTATION_PLAN.md
- 6つのドキュメント参照と、lessons.mdの自己改善ループを含むCLAUDE.mdを書け。
- 初期状態のprogress.txtを作れ。
- 参照用UIスクリーンショットを集めろ。
- gitを初期化し、GitHubへプッシュしろ。

### 作っている間

- AIは毎セッション最初にCLAUDE.md、progress.txt、lessons.mdを読む。
- Cursor（またはClaude）のAsk/Planモードで、コーディング前に設計する。
- Agent mode / Claude Code / Kimi K2.5で実装する（タスクに応じてツールを合わせる）。
- 小さく作る。機能は1つずつ。
- カノニカルドキュメントを参照し、語彙豊かな具体プロンプトを出す。
- UI作業ではスクショ参照を使う。
- 動く機能ごとにgitへコミットする。
- 機能ごとにprogress.txtを更新する。
- 修正のたびにCLAUDE.mdとlessons.mdを更新し、AIが同じミスを二度としないようにする。
- アーキが固まったら、Codexでデバッグ/レビュー/仕上げをする。
- モバイルで定期的にテストする。
- エラーを読み、パニックにならない。

### 出荷前に

- モバイル確認
- エラーステートと空状態の確認
- シークレットが隠れていることの検証
- 主要ユーザーフローをエンドツーエンドでテスト
- パフォーマンス確認（遅いところはないか？）

### 出荷後に

- 作ったものを反映するようドキュメントを更新する
- 依存関係を定期的に更新する
- 実ユーザーフィードバックで反復する
- futureセッションのためにprogress.txtとlessons.mdを最新に保つ
- 繰り返しワークフローは再利用スキル/スラッシュコマンドにする

これが完全なシステムだ。

vibe codingは、魔術でも黒魔術でもない。必要なのは、緻密な計画、システム、ドキュメント、語彙、反復だけだ。アイデアを尋問し、Markdownドキュメントを書き、CLAUDE.md / progress.txt / lessons.mdで永続化と自己改善をセットアップする。フェーズごとに正しいツールを使う：聞く/考える/計画するのはClaude。作るのはCursorの各モード。視覚実装はKimi K2.5。デバッグと仕上げはCodex。仕事を具体的な用語で記述し、セッション間の進捗を追跡し、コードをコミットし、そして出荷する。

AIはタイピングを全部やる。あなたは思考を全部やる。

もう言い訳はない。

今日、何かを作れ。マジで。

ここまで来たなら、ブックマークして二度と戻ってこない99%の人より、あなたはもう先にいる。そいつらより良くあれ。

注：俺は伝統的な開発者じゃない。独学だ。このガイドのすべては、苦労して作って、壊して、理由を突き止めて、実際に効いたことを書き留める――というやり方から来ている。何かが間違っている、欠けている、古くなっているなら教えてくれ。これは生きたドキュメントで、誰かが悪い助言の上に建てるくらいなら、直したい。

AI、vibe coding、生成AIの洞察をもっと見たいなら、（@kloss_xyz）をフォローしてくれ。
